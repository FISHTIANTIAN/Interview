聊到组件状态共享，可能你能口若悬河的说出N种方法，但是要问起组件之间状态共享最合理的方法，你能答上来吗？也许我们熟知的某些可以用来状态共享的方法，并不适合作为组件状态共享的手段，所以今天我们就来探索一下，组件状态共享的正确姿势。

我们应该都知道，组件之间的关系并不是唯一的，对于不同关系的组件，状态共享的合理方式也各不相同，所以我们先来看看一般项目中，组件都有哪些关系。

## 组件之间的关系

一般 SPA（single page application 单文件应用）程序，它的组件组织方式一定是树形的，Vue作为SPA的佼佼者也不例外，下图是典型的一个Vue组件结构。

<center>
    <img
       style="margin-top:10px;
              border-radius: 0.3125em;
              width: 50%;
              height: 100%;
              box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
         src="http://qiniu.begonia.cool/vue/vue-components-relation.png">
    <br>
    <div style="color:orange;
                border-bottom: 1px solid #d9d9d9;
                margin-top: 10px;
                display: inline-block;
                color: #999;
                padding: 2px;">Vue组件树</div>
</center>

由图片所示，我们可以清晰的看到组件之间关系：

- 父子组件（例如：A 与 B、C、D）
- 兄弟组件（例如：B 与 C）
- 叶子与根（例如：E 与 A）
- 叶子与节点（例如：E 与 D）

上面的关系基本包含了我们能见到的绝大多数场景，当然也有少部分类外，比如我们手动挂载到文档中的组件，它可能与组件树是一个并列关系，这里暂且不考虑这些特殊情况。

## 父子组件通信问题

父子组件的关系，是Vue中最常见，处理起来也是最简单的一种，基本靠props + emit就搞定了，不过对于一些业务场景的灵活应用，有必要总结一些心得。

### 父子组件的“双向绑定问题”

在开发中，我遇到的比较特殊一点的变种就是，父子组价之间的双向绑定，众所周知，Vue注重的是[单向数据流](https://cn.vuejs.org/v2/guide/components-props.html#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81)，数据只能由父组件流向子组件，子组件是没办法直接传递数据到父组件的。

一般情况处理这种场景，我们都是子组件emit一个事件，父组件注册一个事件处理函数来处理父子组件之间的状态共享的问题，那万一业务比较复杂，需要共享的状态很多呢，大量的emit导致代码比较冗余，原本的业务逻辑也不清晰了，有没有父子组件之间的`v-model`呢？

其实这些问题，官方也有考虑到，所以Vue的api中出现了一个`.sync`事件修饰符，来简化我们父子组件之间的事件通信，具体文档可以[看这里](https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6)，但是说明白了，它并没有真正的实现父子组件之间的`v-model`，它只是prop和emit的一个语法糖，本质上的原理还是和emit的处理方式一样。

### 函数作为props的灵活应用

在某些情况下，我们也许只需要在子组件特定的时期调用某个父组件的方法并且不执行任何子组件的副作用，例如在一个文件上传组件（下面简称Upload）的文件操作执行阶段绑定一些钩子函数（开始上传、上传成功、上传失败等等），这时候我们可以把函数作为props传递给Upload，在Upload特定的执行阶段调用这些钩子，达到我们的业务需求。

> 需要注意的是，通过props传入的函数，它的this绑定的是声明该函数时的上下文，简而言之，就是传入者的this，并且这个this并不会被`call`、`apply`、`bind` 函数修改，所以当我们将函数作为props使用的时候，不能在函数中执行子组件的副作用。

这个方法的好处是组件与业务的解耦，保证了子组件的纯粹性，在我们设计一些比较通用的组件的时候，这是一个非常不错的手段。

### 小结

父子组件的通信问题，在整个组件通信问题中是最简单的一个，一句话概括一下上述内容，1.普通的父子组件通信问题，靠props/emit 解决，遇到父子组件的数据绑定问题时可以依靠`.sync`修饰符简化代码。2.当遇到子组件需要向父组件提供事件钩子的问题时，可以通过将函数作为props传入子组件的方式来保证子组件的纯粹性。此外的其他组件通信方式，虽然能做到父子组件的通信，但是不适合作为父子组件通信的手段。

## 兄弟组件的通信问题

想到刚刚学习Vue的时候，遇到兄弟组件通信的问题可把我给难住了，因为Vue的数据流向是由父组件到子组件的纵向流动，而兄弟组件之间的通信需要数据的横向流动，但是Vue并不支持我们这么做，那么只能跳出来看整个组件树，我们会发现，兄弟组件的唯一联系，就是他们来自同一个根（父组件），那么我们就可以简化问题，把问题抽象成两条父子组件的通信问题。

### 简化问题之状态提升

先来说一下，什么是状态提升：

>**共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)**

用简单的话概括一下就是：把需要共享的状态，声明到需要共享组件的共同父组件，在兄弟组件通信的问题中，就是将共享状态声明在父组件。

<center>
    <img
       style="margin-top:10px;
              border-radius: 0.3125em;
              width: 50%;
              height: 100%;
              box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
         src="http://qiniu.begonia.cool/vue/state_up.png">
    <br>
    <div style="color:orange;
                border-bottom: 1px solid #d9d9d9;
                margin-top: 10px;
                display: inline-block;
                color: #999;
                padding: 2px;">状态提升示意图</div>
</center>

这样，我们就把兄弟组件通信的问题，变成了兄弟1 -> 父 ->兄弟2的父子组件通信模式，符合了Vue数据流动的规则，也使代码的逻辑更加合理。

兄弟组件通信问题解决的一般思路都是状态提升，当然也可以使用Vuex等状态管理库，如果仅仅是单纯的兄弟组件通信，建议你还是直接使用状态提升，毕竟Vuex用来做兄弟组件通信，有点杀鸡用牛到的意思。

## 叶子与根组件的通信问题

一般也称作爷孙组件的通信问题。

对于这个问题，可以套用前面分析兄弟组件的通信问题，使用状态提升可以解决（当然，也仅仅是针对嵌套层级并不深的情况下），如果嵌套层级大于3级，那么使用状态提升就是一个比较愚蠢的行为了，因为多层级中的状态提升会严重影响代码的可读性。

### 中心化处理是基本手段

通过对状态提升思想的进一步总结，我们就会得出一个结论--状态管理的基本手段是中心化。

试想，将状态提升到父组件，不就是将数据集中到父组件，然后再统一分配嘛，那么父组件就是这个状态管理的“中心”，在叶子与根的问题中，我们不就是把叶子的状态提升到根上面，那么根就是这个状态管理的“中心”，那么我们就可以举一反三的实现一下，中心化状态管理就是处理复杂关系的基本思想。

那么，我们就又得出一个结论，任何能实现状态中心化的手段，都可以用来处理叶子与根的组件的通信问题，常用的手段有：

- Vuex、Bus等状态管理工具（建议）
- provide/inject（较为矛盾）
- 状态提升（层级较深不建议）

>provide/inject，标记为矛盾的原因是，虽然可以实现中心化的状态共享，但是Vue的文档中注明，该方法适合在开发组件库和高阶插件的时候使用，不推荐用于普通程序。
>
>后面会单独针对这个方法深入研究一番。

## 叶子与节点组件的通信问题

同叶子与根组件的通信思考方式相同，不过需要进一步状态提升，在图<Vue组件树>中，需要将状态提升至A组件，然后套用叶子与根组件的处理模式。

##盘点那些不建议用来组件通信的手段

下面将会提到的一些组件通信手段，是在一些面经中被提到，理论上可以实现组件通信，但是并不适合用来组件通信的一些手段，希望大家在使用的过程中，不要被误导。

### \$parent与\$chiildren

不推荐的原因是因为它的表意不清晰，如果一个组件被多个父组件调用，那么\$parent指的是哪个呢？如果一个组件有多个子组件\$children指的又是哪一个呢，且\$children非响应式，容易给开发带来误导。

在团队开发中，\$parent和\$children给代码的清晰度带来的影响是非常大的。

只能说，这个方法是在某些不得已场景下的hack（理解为合法但不正规）手段。

### localStorage/sessionStorage

诚然，这俩玩意儿是能实现组件通信的，原理就是中心化状态管理。

不推荐的原因是，这俩东西是暴露给用户的，如果拿来做应用通信的话，在用户不经意间清楚了浏览器缓存，那你的程序不就GG了？（你永远猜不到用户会怎么使用你的程序，所以把程序状态暴露给用户是不安全的），所以还是老老实实用它们做客户端存储吧，花里胡哨不要搞。

### \$attrs/\$listeners

奇怪的知识又增加了。

尝试了一下，发现其实是可以完成组件通信的，但是发现其可读性并不是很好，如果是私人项目，或者比较小的项目可以使用，如果是团队项目的话，建议不要乱用，小心被打。

到此，今天的博客就分享完了，如果有问题，可以在评论区指出，如果有收获，可以点个小心心支持一下。

>作者：Begonia
>首发于：http://begonia.cool
>原文：http://begonia.cool/article?id=1