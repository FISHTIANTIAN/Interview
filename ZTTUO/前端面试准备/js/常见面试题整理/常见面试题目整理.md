## JS 事件循环是什么？

因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎不会一直等待其返回结果，而是会将这时间挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对于的回调浇入到与当前执行栈中不同的另外一个任务队列中等待执行。任务队列分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将委任队列队首的事件压入执行栈中执行。当为任务队列中的任务执行完毕后才会去判断宏任务中的任务。

微任务包括了 promies 的回调，nextTick，MutationObserver 等；

宏任务包括了 script 脚本的执行，setTimeout，setInterval，setImmediate，I/O 操作，UI 渲染等；

## 深浅拷贝的实现

- 浅拷贝

浅拷贝指的是将一个对象的属性赋值给另外一个对象，如果哟肚饿属性只为应用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 Object.assign 和展开运算符（...）来实现。

- 深拷贝

深拷贝相对于浅拷贝而言，如果遇到属性值为引用类型的时候，他新建一个引用类型并将对应的值复制给他，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 JS 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。

## ES5/ES6 的继承除了写法外还有什么区别？

- class 声明会提升，但不会初始化赋值；（类似于 let、const 声明变量）
- class 声明内部会启用严格模式；
- class 的所有方法（包括静态方法和实例方法）都是不可枚举的；
- class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有 [[constructor]]，不能使用 new 来调用；
- 必须使用 new 来调用 class；
- class 内部无法重写类名；

## JS 异步解决方案以及优缺点

- 回调函数

优点：解决了同步的问题（争议任务执行时长）；

缺点：回调地狱，不能使用 try catch 捕获错误，不能使用 return；

- Promise

优点：解决了回调地狱；

缺点：错误必须要使用错误回调来捕获；

- Generator

特点：可以控制函数的执行

- Async/Await

优点：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题；

缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低；

## 介绍下 Set、Map、WeakSet 和 WeakMap 的区别

- Set 
    - 成员不能重复；
    - 只有键值，没有键名，有点类似数组；
    - 可以遍历，方法有 add、delete、has
- WeakSet
    - 成员都是对象（引用）；
    - 成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄露；
    - 不能遍历，方法有 add、delete、has；
- Map
    - 本质上是键值对的集合，类似集合；
    - 可以遍历，方法很多，可以跟各种数据格式转换；
- WeakMap
    - 只接收对象为键名（null 除外），不接受其他类型的值作为键名；
    - 键名指向的对象，不计入垃圾回收机制；
    - 不能遍历，方法同 get、set、has、delete；