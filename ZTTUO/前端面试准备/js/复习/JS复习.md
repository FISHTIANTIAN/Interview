## set和map的区别

- set和map的应用场景主要在数据重组和数存储
- set叫做集合，map叫做字典
- 共同点：可以储存不重复的值
- 不通点：set是以[value, value]的方式进行存储，map是以[key, value]的方式进行存储

## weakset和set、map的区别

- weakset只能存储对象引用，不能存放值，而set可以
- weakset中所有的对象都是弱引用的，当垃圾回收机制被触发的时候，内部存储的内容会被回收，可能导致的问题就是未触发的时候可以访问，触发后值不见了
- weakset中的对象都是弱引用，所以其中的key是不可以枚举的，即不能便利，set和map可以遍历

## map和object的区别

- 相同点：两者都是以[key, value]的方式进行存储
- 不同点：
    - map继承自object
    - object中的key必须是简单数据类型(整数、字符串或者symbol)，map则没有限制
    - map访问元素可以使用自带的.get等方式，object可以通过 . 或者[]来访问
    - json直接支持object，但不支持map
    - map是存粹的hash，而object中存在其他逻辑，所以删除的密集操作map更加好
    - map会按照插入顺序保持内部存储的顺序，object做不到
    - map在查找内部元素的性能优于object

## Array.prototype

- .filter()
    - filter()方法创建一个新的数组，其中包含通过固定要求的值

- .every()
    - every()方法测试所有的内容是否都能通过固定的要求，通过返回ture否则false

- .flat()
    - flat()方法课题深层便利一个数组，并将其所有的元素合并为固定维度的数组并返回，默认为一维数组

## event loop

首先，js是单线程的，他的目的在于处理用户的交互，而交互的话，无非都是一些元素的增删改，而每次只会允许执行一个动作，可是单线程的机制，会导致一个操作的运行会阻塞后面的内容运行。所以出现了任务队列的机制，在任务一步一步执行中也是有先后顺序的规则的，首先他会先判断当前任务是否存在微任务，微任务优先执行，如果其中遇到的宏任务，就会将宏任务放到下一次的循环中，然后微任务执行结束后执行宏任务，以此头尾相接进行循环，这也就是事件循环。还有就是微任务引入的初衷也是为了解决异步回调的问题，对于异步回调的处理方法，我理解的有两种：一种是放到宏任务的队头，一种是放到宏任务的队尾。第一种方式的话会导致当前任务非常长的话，回调就迟迟不会执行，则会卡顿。所以浏览器最终使用了第二种方式，这也是微任务的解决方式，每次宏任务结束会检查是否存在微任务，有的话会继续执行微任务，直到全部为空，然后才会执行下一次的宏任务

## promise

- promies解决了回调地狱的问题
    - 回调函数不是直接申明的，而是通过.then方法传入的，这就是回调函数延迟绑定
    - 可以将返回值穿透到promies的外层，交给其他内容进行处理，这就是返回值穿透
    - 通过catch进行错误冒泡